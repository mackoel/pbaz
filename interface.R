library('RJDBC')

dbnam <- "pbaz"

drv <- JDBC("org.hsqldb.jdbcDriver",  "../hsqldb.jar")

conn <- dbConnect(drv, "jdbc:hsqldb:hsql://localhost/pbaz")

SQL <- c(
	"SELECT name FROM variety where origin = 'tab' LIMIT 8"
)

ret.varities.df <- dbGetQuery(conn, SQL)

SQL <- c(
	"SELECT gname FROM genotype LIMIT 8"
)

ret.gt.df <- dbGetQuery(conn, SQL)

SQL <- c(
	"SELECT snpabbr FROM gt_snp LIMIT 8"
)

ret.snp.df <- dbGetQuery(conn, SQL)

SQL <- c(
	"SELECT NEXT VALUE FOR TTN_SEQUENCE"
)

SQL <- c(
	"call NEXT VALUE FOR TTN_SEQUENCE"
)

ret.ttn <- dbGetQuery(conn, SQL)

ttname <- paste0("TTN_NAME_", ret.ttn[1,1])

clnms <- paste(ret.snp.df$SNPABBR, "INTEGER", collapse = ",")

SQL <- c(
	"CREATE TABLE @TTNAME@ (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, gt VARCHAR(64), @CLNMS@)"
)

SQL <- gsub("@CLNMS@", clnms, SQL)
SQL <- gsub("@TTNAME@", ttname, SQL)

dbSendUpdate(conn, SQL)

ret <- apply(ret.gt.df, 1, FUN=function(g) {
	tryCatch(
		{
			qu <- paste0("INSERT INTO ", ttname, " (gt) VALUES ('", g, "')")
			cat (qu, '\n')
			dbSendUpdate(conn, qu)
		},
        error=function(cond) {
            message(cond)
            # Choose a return value in case of error
            return(NA)
        },
        warning=function(cond) {
            message(cond)
            # Choose a return value in case of warning
            return(NULL)
        },
        finally={
        # NOTE:
        # Here goes everything that should be executed at the end,
        # regardless of success or error.
        # If you want more than one expression to be executed, then you
        # need to wrap them in curly brackets ({...}); otherwise you could
        # just have written 'finally=<expression>'
            message("Some other message at the end")
        }
    )
	lapply(ret.snp.df$SNPABBR, FUN=function(snp) {
		qus <- paste0("SELECT ndom FROM gt_snp WHERE gt = '", g, "' AND snpabbr = '", snp, "'")
		cat (qus, '\n')
		ret.ndom <- dbGetQuery(conn, qus)
		cat (ret.ndom[1,1], '\n')
		if (!is.na(ret.ndom[1,1])) {
			qui <- paste0("UPDATE ", ttname, " SET ", snp, " = ", ret.ndom[1,1], " WHERE gt = '", g, "'")
			cat (qui, '\n')
			dbSendUpdate(conn, qui)
		}
	})
})

"SELECT gname FROM genotype LIMIT 8"
"SELECT snpabbr FROM gt_snp LIMIT 8"

SQL <- c("
	CREATE PROCEDURE X_GT_SNP (
	    GTPAR VARCHAR(100),
	    SNPPAR VARCHAR(100))
	RETURNS (
	    SQL VARCHAR(2000))
	AS
	DECLARE VARIABLE SELECT_SQL VARCHAR(2000);
	DECLARE VARIABLE AND_SQL VARCHAR(2000);
	BEGIN

	    SELECT_SQL = 'SELECT ndom FROM gt_snp WHERE gt = ' || ASCII_CHAR(13);
	    AND_SQL = 'AND snpabbr = ' || ASCII_CHAR(13);
	    SQL = 'U' || ASCII_CHAR(13);

	    FOR
		SELECT DISTINCT gname FROM genotype
		INTO :GT LIMIT 8
		DO
		BEGIN

		FOR
		    SELECT DISTINCT snpabbr FROM snp
		    INTO :SN LIMIT 8
		    DO
		    BEGIN
			SQL = :SQL || :SELECT_SQL || :GT || :AND_SQL || :SNP || ';' || ASCII_CHAR(13);

		    END


		END
	SUSPEND;
	END

")
dbSendUpdate(conn, SQL)


dbGetQuery(conn, 'select x_gt_snp(snpabbr, chrname) from snp limit 6')


dbSendUpdate(conn, "DROP FUNCTION X_GT_SNP")

SQL <- c("
	CREATE FUNCTION X_GT_SNP (gt_par VARCHAR(100), snp_par VARCHAR(100)) RETURNS VARCHAR(2000)
	READS SQL DATA
	BEGIN ATOMIC
	    DECLARE select_sq VARCHAR(2000);
	    DECLARE and_sq VARCHAR(2000);
	    DECLARE sq VARCHAR(2000);
	    SET select_sq = 'SELECT ndom FROM gt_snp WHERE gt = ';
	    SET and_sq = 'AND snpabbr = ';
	    SET sq = 'U';
	    g_for_label:
	    FOR SELECT gname FROM genotype LIMIT 2 DO
		s_for_label:
		FOR SELECT snpabbr FROM snp LIMIT 2 DO
		    SET sq = sq || select_sq || gname || and_sq || snpabbr || ';';
		END FOR s_for_label;
	    END FOR g_for_label;
	RETURN sq;
	END

")
dbSendUpdate(conn, SQL)


dbGetQuery(conn, "call x_gt_snp('snpabbr', 'chrname')")



ttname <- paste0("TTN_NAME_", ret.ttn[1,1])

clnms <- paste(ret.snp.df$SNPABBR, "INTEGER", collapse = ",")

SQL <- c(
	"CREATE TABLE @TTNAME@ (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, gt VARCHAR(64), @CLNMS@)"
)

SQL <- gsub("@CLNMS@", clnms, SQL)
SQL <- gsub("@TTNAME@", ttname, SQL)


dbSendUpdate(conn, "DROP PROCEDURE Y_GT_SNP")

	    CREATE TABLE tt_name (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, gt VARCHAR(64));
select * from y_gt_snp ('%Gunas%', '%C_T%')

SQL <- c("
	CREATE OR REPLACE FUNCTION y_gt_snp (gt_par VARCHAR(100), snp_par VARCHAR(100)) RETURNS VARCHAR(256)
	AS
	$BODY$
	DECLARE
	    rec record;
	    req record;
	    n INTEGER;
	    tmpint INTEGER;
	    tt_name VARCHAR(256);
	BEGIN
	    SELECT nextval('ttn_sequence') into n;
	    tt_name := 'TTN_NAME_' || n;
	    CREATE TABLE tt_name (id SERIAL PRIMARY KEY, gt VARCHAR(64));

	    <<n_for_label>>
	    FOR rec IN SELECT snpabbr FROM snp WHERE snpabbr LIKE snp_par LIMIT 16 LOOP
		EXECUTE 'ALTER TABLE tt_name ADD COLUMN "' || rec.snpabbr || '" INTEGER';
	    END LOOP n_for_label;

	    <<g_for_label>>
	    FOR rec IN SELECT gname FROM genotype WHERE gname LIKE gt_par LOOP
		INSERT INTO tt_name (gt) VALUES (rec.gname);
		<<s_for_label>>
		FOR req IN SELECT snpabbr FROM snp WHERE snpabbr LIKE snp_par LIMIT 16 LOOP
		    tmpint := 0;
		    SELECT ndom INTO n FROM gt_snp WHERE gt = rec.gname AND snpabbr = req.snpabbr;
		    GET DIAGNOSTICS tmpint = ROW_COUNT;
		    IF (tmpint = 1) THEN
			UPDATE tt_name SET req.snpabbr = n WHERE gt = rec.gname;
		    END IF;
		END LOOP s_for_label;
	    END LOOP g_for_label;
	    RETURN tt_name;
	END;
	$BODY$ LANGUAGE plpgsql;

")
dbSendStatement(conn, SQL)


dbGetQuery(conn, "SELECT ndom INTO n FROM gt_snp WHERE gt = 'a' AND snpabbr = 'a'")

dbGetQuery(conn, "call x_gt_snp('snpabbr', 'chrname')")



SQL <- c("
	CREATE PROCEDURE Y_GT_SNP (IN gt_par VARCHAR(100), IN snp_par VARCHAR(100), OUT tab_par VARCHAR(256))
	MODIFIES SQL DATA
	BEGIN ATOMIC

	    DECLARE select_sq VARCHAR(2000);
	    DECLARE create_sq VARCHAR(4096);
	    DECLARE and_sq VARCHAR(2000);
	    DECLARE sq VARCHAR(4096);
	    DECLARE n INTEGER;
	    DECLARE tt_name VARCHAR(256);

	    SET n = (NEXT VALUE FOR TTN_SEQUENCE);
	    SET tt_name = 'TTN_NAME_' || n;
	    SET create_sq = 'CREATE TABLE ' || tt_name || ' (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, gt VARCHAR(64) ';

	    CREATE TABLE tt_name (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, gt VARCHAR(64))

	    n_for_label:
	    FOR SELECT snpabbr FROM snp LIKE snp_par DO
		SET create_sq = create_sq || ',' || snpabbr || ' INTEGER';
	    END FOR n_for_label;
	    create_sq = create_sq || ')';
	    SET n = exec(create_sq);

	    SET select_sq = 'SELECT ndom FROM gt_snp WHERE gt = ';
	    SET and_sq = 'AND snpabbr = ';
	    SET sq = '';

	    g_for_label:
	    FOR SELECT gname FROM genotype LIKE gt_par DO
		INSERT INTO tt_name (gt) VALUES (gname);
		s_for_label:
		FOR SELECT snpabbr FROM snp LIKE snp_par DO
		    SET n = SELECT ndom FROM gt_snp WHERE gt = gname AND snpabbr = snpabbr;
		    IF (n) THEN
			UPDATE tt_name SET snpabbr = n WHERE gt = gname;
		    END IF;
		END FOR s_for_label;
	    END FOR g_for_label;
	    SET tab_var = tt_name;
	END

")
dbSendUpdate(conn, SQL)


dbGetQuery(conn, "call x_gt_snp('snpabbr', 'chrname')")

